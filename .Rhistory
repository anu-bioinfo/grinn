h = RCurl::basicTextGatherer()
tryCatch({
#cypher = "MATCH ptw = (from:Protein)-[:CONTROL]->(to:Gene) WHERE from.GID = 'P14859' RETURN DISTINCT ptw LIMIT 2"
url = paste0(nld,"transaction/commit")
#url = "http://localhost:7474/db/data/transaction/commit"
body = paste0("{\"statements\":[{\"statement\":\"",cypher,"\",\"resultDataContents\":[\"graph\"]}]}")
RCurl::curlPerform(url=url,
userpwd = neu,
httpheader = c(Authorization = paste("Basic",RCurl::base64(neu)), 'Content-Type' = "application/json"),
postfields=body,
writefunction = h$update,
verbose = FALSE
)
result <- RJSONIO::fromJSON(h$value())$results[[1]]$data
}, error = function(err) {
message(err)
result <- list() #return empty if not found
})
}
network = curlRequest.TRANSACTION(querystring)
querystring = "UNWIND ['G17151','G17712','G16704','G17775','G17568','G17200','G16264','G28621','G18095','G18145','G4249','G25629','G16610','G15963','G17521','G17203','G42504','G29019','G15756','G15729','G17154','G17122','methionine.sulfoxide','mannitol','G30797','G18019','G30805','G15553','G18384','G17202','G15429','G334.1','G15754','G17754','G32398','G16015','G4167','G33198','G18185','G2179','G2181','G32806','G32806.1','G28878','G16566','G17361','G17561','G16737','G16349','G30769','G28837','G30813','G18138','G30746','arachidonic.acid','G18333','G17535','G17475','G30837','G16977','G16027','G16708','G17509','G15901','G30830','G17794','G17084','G16070','G75557','G35759'] AS x WITH x MATCH ptw = (from:Metabolite)<-[rel:MAP_TO]-(to:Pathway) WHERE lower(from.GID) = lower(x) RETURN DISTINCT ptw"
network = curlRequest.TRANSACTION(querystring)
network
ptm <- proc.time()
network = curlRequestCypher(querystring)
t2 = proc.time() - ptm
curlRequestCypher <- function(querystring){
h = RCurl::basicTextGatherer()
tryCatch({
url = paste0(nld,"cypher")
RCurl::curlPerform(url=url,
userpwd = neu,
httpheader = c(Authorization = paste("Basic",RCurl::base64(neu))),
postfields=paste('query',RCurl::curlEscape(querystring), sep='='),
writefunction = h$update,
verbose = FALSE
)
data <- jsonlite::fromJSON(h$value())
result <- data$data #return as data.frame
}, error = function(err) {
print(err)
result <- NULL #return NULL if not found
}) # END tryCatch
}
ptm <- proc.time()
network = curlRequestCypher(querystring)
t2 = proc.time() - ptm
t2
length(network)
network[[1]]
ptm <- proc.time()
network = curlRequest.TRANSACTION(querystring)
t3 = proc.time() - ptm
t3
ptm <- proc.time()
mptwNW <- fetchGrinnNetwork(txtInput=colnames(sigMet), from="metabolite", to="pathway", returnAs="tab")
t1 = proc.time() - ptm
t1
?foreach
network = curlRequest.TRANSACTION(querystring)
length(network)
network = network[[1]]
network = curlRequest.TRANSACTION(querystring)
network[1:2]
network = network[1:3]
network
dim(mptwNW$nodes)
mptwNW$nodes[1:5,]
mptwNW$edges[1:5,]
network[[1]]
network[[1]]$graph$relationships[[1]]$properties["source"]
unlist(network[[1]]$graph$relationships[[1]]$properties["source"])
graph$graph$nodes[[1]]$properties$GID
network[[1]]$graph$nodes[[1]]$properties$GID
network[[1]]$graph$nodes[[1]]$properties$xref
paste0(graph$graph$nodes[[1]]$properties$xref,collapse = "||")
paste0(network[[1]]$graph$nodes[[1]]$properties$xref,collapse = "||")
pair = lapply(network, function(x) rbind(fetchRelation.TRANSACTION(x)))
fetchRelation.TRANSACTION <- function(graph){
out <- tryCatch(
{
type = graph$graph$relationships[[1]]$type
dataSource = graph$graph$relationships[[1]]$properties["source"]
startGID = graph$graph$nodes[[1]]$properties$GID
startName = graph$graph$nodes[[1]]$properties$name
startXref = paste0(graph$graph$nodes[[1]]$properties$xref,collapse = "||")
startLabel = graph$graph$nodes[[1]]$labels
endGID = graph$graph$nodes[[2]]$properties$GID
endName = graph$graph$nodes[[2]]$properties$name
endXref = paste0(graph$graph$nodes[[2]]$properties$xref,collapse = "||")
endLabel = graph$graph$nodes[[2]]$labels
reltype = paste0(startLabel,"_",endLabel)
## Set the name for the class
relation = list(startGID=startGID, startName=startName, startXref=startXref, startLabel=startLabel,
endGID=endGID, endName=endName, endXref=endXref, endLabel=endLabel, relsource=dataSource, relname=type, reltype=reltype)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
pair = lapply(network, function(x) rbind(fetchRelation.TRANSACTION(x)))
pair
fetchRelation.TRANSACTION(network[[1]])
pair = lapply(network, function(x) data.frame(t(sapply(fetchRelation.TRANSACTION(x),c))))
pair
pair1 = lapply(network, function(x) fetchRelation.TRANSACTION(x))
pair
pair1
pair = data.frame(t(sapply(pair1,c)))
pair
pair[,c(1,5)]
mptwNW$edges[1:3,]
network
cypher
querystring
pair[,c(1,5)]
fetchRelation.TRANSACTION <- function(graph){
out <- tryCatch(
{
type = graph$graph$relationships[[1]]$type
dataSource = graph$graph$relationships[[1]]$properties["source"]
source = graph$graph$nodes[[1]]$properties$GID
target = graph$graph$nodes[[2]]$properties$GID
## Set the name for the class
relation = list(source=graph$graph$relationships[[1]]$startNode, target=graph$graph$relationships[[1]]$endNode, relname=graph$graph$relationships[[1]]$type, relsource=graph$graph$relationships[[1]]$properties["source"])
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
pair1 = lapply(network, function(x) fetchRelation.TRANSACTION(x))
pair
fetchRelation.TRANSACTION <- function(graph){
out <- tryCatch(
{
type = graph$graph$relationships[[1]]$type
dataSource = graph$graph$relationships[[1]]$properties["source"]
source = graph$graph$nodes[[1]]$properties$GID
target = graph$graph$nodes[[2]]$properties$GID
## Set the name for the class
relation = list(source=graph$graph$relationships[[1]]$startNode, target=graph$graph$relationships[[1]]$endNode, relname=graph$graph$relationships[[1]]$type, relsource=graph$graph$relationships[[1]]$properties["source"])
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
pair1 = lapply(network, function(x) fetchRelation.TRANSACTION(x))
pair1
pair = data.frame(t(sapply(pair1,c)))
pair
pair = data.frame(t(sapply(network,c)))
pair
pair = data.frame(t(sapply(network,function(x)fetchRelation.TRANSACTION(x))))
pair
rm(pair)
pair = data.frame(t(sapply(network,function(x)fetchRelation.TRANSACTION(x))))
pair
network[[1]]
network[[1]]$graph$nodes
network[[1]]$graph$nodes[[1]]
fetchNode.TRANSACTION <- function(node){
out <- tryCatch(
{
nodeInfo = list(id=node$id, gid=node$properties$GID, nodename=node$properties$name, xref=paste0(node$properties$xref,collapse = "||"), nodetype=node$labels)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
network
network[[1]]
network[[1]]$graph
attb = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph))))
attb
attb = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes))))
attb
network[[1]]$graph$nodes
unlist(network, recursive = F)
unlist(network, recursive = F)$graph
unlist(network, recursive = F)$graph$nodes
attb = data.frame(t(sapply(unlist(network, recursive = F)$graph$nodes, function(x) fetchNode.TRANSACTION(x))))
attb
network
attb
apri
pair
unlist(network, recursive = F)$graph$nodes
network
attr(network[[1]]$graph,"nodes")
attr(network[[1]]$graph$nodes,"nodes")
unlist(network, recursive = F)
unlist(network, recursive = F)$graph
unlist(network, recursive = F)
unlist(network, recursive = F)$nodes
unlist(network, recursive = F)$graph$nodes
attb = data.frame(t(sapply(network, function(x) sapply(x$graph$nodes, fetchNode.TRANSACTION(x)))))
attb = data.frame(t(sapply(network, function(x) sapply(x$graph$nodes, function(y) fetchNode.TRANSACTION(y)))))
attb
attb[,1:2]
sapply(network)
sapply(network,cat)
str(network)
sapply(network,unlist)
unlist(network, recursive = F)
str(unlist(network, recursive = F))
sapply(unlist(network, recursive = F),function(x) print(x$nodes)
)
sapply(unlist(network, recursive = F),function(x) print(x$nodes))
lapply(unlist(network, recursive = F),function(x) print(x$nodes))
lapply(unlist(network, recursive = F),function(x) x$nodes)
length(lapply(unlist(network, recursive = F),function(x) x$nodes))
unlist(lapply(unlist(network, recursive = F),function(x) x$nodes), recursive = FALSE)
data.frame(lapply(unlist(network, recursive = F),function(x) x$nodes))
(lapply(unlist(network, recursive = F),function(x) x$nodes))
length(lapply(unlist(network, recursive = F),function(x) x$nodes))
(lapply(unlist(network, recursive = F),function(x) x$nodes))[1]
(lapply(unlist(network, recursive = F),function(x) x$nodes))[2]
(lapply(unlist(network, recursive = F),function(x) x$nodes))[[2]]
nodels = lapply(unlist(network, recursive = F),function(x) x$nodes)
length(nodels)
nodels[[1]]
attb = data.frame(t(sapply(nodels, function(x) fetchNode.TRANSACTION(x))))
attb
sapply(nodels)
sapply(nodels,c)
nodels
data.frame(nodels)
data.frame(t(sapply(nodels,c))
)
nodels[[1]]
unlist(nodels[[1]], recursive = F)
data.frame(unlist(nodels[[1]], recursive = F))
length(unlist(nodels[[1]], recursive = F))
data.frame(t(sapply(nodels[[1]],c)))
nodels
unlist(nodels, recursive = FALSE)
xx = unlist(nodels, recursive = FALSE)
xx[1]
xx[[1]]
xx
unlist(xx, recursive = FALSE)
network[[1]]
network[[1]]$graph
nodels = network[[1]]$graph
nodels
nodels$nodes[[1]]
nodels$nodes[[1]]$id
nodels$nodes[[1]]$properties$GID
fetchNode.TRANSACTION <- function(graph){
out <- tryCatch(
{
nodels = network[[1]]$graph
so = data.frame(id=nodels$nodes[[1]]$id, gid=nodels$nodes[[1]]$properties$GID, nodename=nodels$nodes[[1]]$properties$name, xref=paste0(nodels$nodes[[1]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[1]]$labels, stringsAsFactors = FALSE, row.names = NULL)
ta = data.frame(id=nodels$nodes[[2]]$id, gid=nodels$nodes[[2]]$properties$GID, nodename=nodels$nodes[[2]]$properties$name, xref=paste0(nodels$nodes[[2]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[2]]$labels, stringsAsFactors = FALSE, row.names = NULL)
nodeInfo = unique(rbind(so,ta))
#nodeInfo = list(id=node$id, gid=node$properties$GID, nodename=node$properties$name, xref=paste0(node$properties$xref,collapse = "||"), nodetype=node$labels)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = data.frame() # Choose a return value in case of error
})
return(out)
}
fetchNode.TRANSACTION <- function(graph){
out <- tryCatch(
{
nodels = graph$graph
so = data.frame(id=nodels$nodes[[1]]$id, gid=nodels$nodes[[1]]$properties$GID, nodename=nodels$nodes[[1]]$properties$name, xref=paste0(nodels$nodes[[1]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[1]]$labels, stringsAsFactors = FALSE, row.names = NULL)
ta = data.frame(id=nodels$nodes[[2]]$id, gid=nodels$nodes[[2]]$properties$GID, nodename=nodels$nodes[[2]]$properties$name, xref=paste0(nodels$nodes[[2]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[2]]$labels, stringsAsFactors = FALSE, row.names = NULL)
nodeInfo = unique(rbind(so,ta))
#nodeInfo = list(id=node$id, gid=node$properties$GID, nodename=node$properties$name, xref=paste0(node$properties$xref,collapse = "||"), nodetype=node$labels)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = data.frame() # Choose a return value in case of error
})
return(out)
}
fetchNode.TRANSACTION(network[[1]])
attb = sapply(network, function(x) fetchNode.TRANSACTION(x))
attb
attb = lapply(network, function(x) fetchNode.TRANSACTION(x))
attb
t(attn)
t(attb)
unlist(attb,recursive = FALSE)
attb = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x))))
attb
fetchNode.TRANSACTION <- function(node){
out <- tryCatch(
{
#nodels = graph$graph
#so = data.frame(id=nodels$nodes[[1]]$id, gid=nodels$nodes[[1]]$properties$GID, nodename=nodels$nodes[[1]]$properties$name, xref=paste0(nodels$nodes[[1]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[1]]$labels, stringsAsFactors = FALSE, row.names = NULL)
#ta = data.frame(id=nodels$nodes[[2]]$id, gid=nodels$nodes[[2]]$properties$GID, nodename=nodels$nodes[[2]]$properties$name, xref=paste0(nodels$nodes[[2]]$properties$xref,collapse = "||"), nodetype=nodels$nodes[[2]]$labels, stringsAsFactors = FALSE, row.names = NULL)
#nodeInfo = unique(rbind(so,ta))
nodeInfo = list(id=node$id, gid=node$properties$GID, nodename=node$properties$name, xref=paste0(node$properties$xref,collapse = "||"), nodetype=node$labels)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = data.frame() # Choose a return value in case of error
})
return(out)
}
attbx = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[1]]))))
attbx
attby = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[2]]))))
attby
pair
attb = unique(rbind(attbx,attby))
attb
querystring
formatNetworkOutput <- function(network,returnAs){
pair = data.frame() #list of mapped nodes
attb = data.frame() #list of node attributes
cat("Formating and returning queried network...\n")
if(length(network)<6000){
pair = data.frame(t(sapply(network, function(x) fetchRelation.TRANSACTION(x))))
attbs = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[1]]))))
attbt = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[2]]))))
attb = unique(rbind(attbs,attbt))
#     for(i in 1:length(network)){
#       path = lapply(unlist(network[[i]]$relationships),fetchRelation)
#       tmppair = data.frame(t(sapply(path,c)))
#       reltype = paste0(tmppair[,4],"_",tmppair[,8])
#       tmppair = unname(tmppair)
#       attb = rbind(attb,as.matrix(tmppair[,c(1:4)]),as.matrix(tmppair[,c(5:8)]))
#       tmppair = tmppair[,c(1,5,10,9)]
#       pair = rbind(pair,cbind(tmppair,reltype)) #from-to-relname-reltype
#     }
}else{
cat("Found ",length(network)," but returning 6000 of all relationships...\n")
for(i in 1:6000){
path = lapply(unlist(network[[i]]$relationships),fetchRelation)
tmppair = data.frame(t(sapply(path,c)))
reltype = paste0(tmppair[,4],"_",tmppair[,8])
tmppair = unname(tmppair)
attb = rbind(attb,as.matrix(tmppair[,c(1:4)]),as.matrix(tmppair[,c(5:8)]))
tmppair = tmppair[,c(1,5,10,9)]
pair = rbind(pair,cbind(tmppair,reltype)) #from-to-relname-reltype
}
}
#   if(length(pair)>0){
#     pair <- unique(pair)
#     attb <- unique(attb)
#     cat("Found ",nrow(pair)," relationships...\n")
#     colnames(pair) = c("source","target","relsource","relname","reltype")
#     colnames(attb) = c("id","nodename","xref","nodetype")
#     #network in cytoscapeJS format
#     #cynetwork = createCyNetwork(attb, pair)
#
#   }else{# if no mapped node found
#     print("Returning no data...")
#     cynetwork = list(nodes="", edges="")
#   }
out = switch(returnAs,
tab = list(nodes=attb, edges=pair),
json = list(nodes=jsonlite::toJSON(attb), edges=jsonlite::toJSON(pair)),
cytoscape = createCyNetwork(attb, pair),
stop("incorrect return type"))
}
network = curlRequest.TRANSACTION(querystring)
fetchRelation.TRANSACTION <- function(graph){
out <- tryCatch(
{
## Set the name for the class
relationInfo = list(source=graph$graph$relationships[[1]]$startNode, target=graph$graph$relationships[[1]]$endNode, relname=graph$graph$relationships[[1]]$type, relsource=graph$graph$relationships[[1]]$properties["source"])
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
fetchNode.TRANSACTION <- function(node){
out <- tryCatch(
{
nodeInfo = list(id=node$id, gid=node$properties$GID, nodename=node$properties$name, xref=paste0(node$properties$xref,collapse = "||"), nodetype=node$labels)
},
error=function(e) {
message(e)
cat("\n..RETURN empty list of relations")
out = list() # Choose a return value in case of error
})
return(out)
}
nn = formatNetworkOutput(network,returnAs = "tab")
str(nn)
dim(nn$nodes)
nn$nodes[1:10,]
nn$edges[1:10,]
ptm <- proc.time()
network = curlRequest.TRANSACTION(querystring)
nn = formatNetworkOutput(network,returnAs = "tab")
t3 = proc.time() - ptm
t3
length(network)
network[[1]]
network[1:2]
formatNetworkOutput <- function(network,returnAs){
pair = data.frame() #list of mapped nodes
attb = data.frame() #list of node attributes
cat("Formating and returning queried network...\n")
if(length(network)<1){
pair = data.frame(t(sapply(network, function(x) fetchRelation.TRANSACTION(x))))
attbs = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[1]]))))
attbt = data.frame(t(sapply(network, function(x) fetchNode.TRANSACTION(x$graph$nodes[[2]]))))
attb = unique(rbind(attbs,attbt))
#     for(i in 1:length(network)){
#       path = lapply(unlist(network[[i]]$relationships),fetchRelation)
#       tmppair = data.frame(t(sapply(path,c)))
#       reltype = paste0(tmppair[,4],"_",tmppair[,8])
#       tmppair = unname(tmppair)
#       attb = rbind(attb,as.matrix(tmppair[,c(1:4)]),as.matrix(tmppair[,c(5:8)]))
#       tmppair = tmppair[,c(1,5,10,9)]
#       pair = rbind(pair,cbind(tmppair,reltype)) #from-to-relname-reltype
#     }
}else{
cat("Found ",length(network)," but returning 10000 of all relationships...\n")
pair = data.frame(t(sapply(network[1:2], function(x) fetchRelation.TRANSACTION(x))))
attbs = data.frame(t(sapply(network[1:2], function(x) fetchNode.TRANSACTION(x$graph$nodes[[1]]))))
attbt = data.frame(t(sapply(network[1:2], function(x) fetchNode.TRANSACTION(x$graph$nodes[[2]]))))
attb = unique(rbind(attbs,attbt))
}
#   if(length(pair)>0){
#     pair <- unique(pair)
#     attb <- unique(attb)
#     cat("Found ",nrow(pair)," relationships...\n")
#     colnames(pair) = c("source","target","relsource","relname","reltype")
#     colnames(attb) = c("id","nodename","xref","nodetype")
#     #network in cytoscapeJS format
#     #cynetwork = createCyNetwork(attb, pair)
#
#   }else{# if no mapped node found
#     print("Returning no data...")
#     cynetwork = list(nodes="", edges="")
#   }
out = switch(returnAs,
tab = list(nodes=attb, edges=pair),
json = list(nodes=jsonlite::toJSON(attb), edges=jsonlite::toJSON(pair)),
cytoscape = createCyNetwork(attb, pair),
stop("incorrect return type"))
}
nn = formatNetworkOutput(network,returnAs = "tab")
nn
library(grinn)
ptm <- proc.time()
mptwNW <- fetchGrinnNetwork(txtInput=colnames(sigMet), from="metabolite", to="pathway", returnAs="tab")
t1 = proc.time() - ptm
t1
library(grinn)
ptm <- proc.time()
mptwNW <- fetchGrinnNetwork(txtInput=colnames(sigMet), from="metabolite", to="pathway", returnAs="tab")
t1 = proc.time() - ptm
library(grinn)
txtInput <- list('P05108','Q53H96','P18463')
result <- fetchGrinnNetwork(txtInput, from="protein", to="pathway", filterSource="SMPDB", returnAs="cytoscape", dbXref="uniprot")
ptm <- proc.time()
mptwNW <- fetchGrinnNetwork(txtInput=colnames(sigMet), from="metabolite", to="pathway", returnAs="tab")
t1 = proc.time() - ptm
library(grinn)
ptm <- proc.time()
mptwNW <- fetchGrinnNetwork(txtInput=colnames(sigMet), from="metabolite", to="pathway", returnAs="tab")
t1 = proc.time() - ptm
t1
library(grinn)
?convertToGrinnID
txtInput <- list('ENSG00000140459','ENSG00000143811','ENSG00000104524')
result <- convertToGrinnID(txtInput, nodetype="gene", dbXref="ensembl")
result
ptm <- proc.time()
txtInput <- list('ENSG00000140459','ENSG00000143811','ENSG00000104524','ENSG00000104525','ENSG00000104526','ENSG00000104527','ENSG00000104530','ENSG00000104514','ENSG00000103524')
result <- convertToGrinnID(txtInput, nodetype="gene", dbXref="ensembl")
t3 = proc.time() - ptm
t3
kw <- c('G160','G300','G371')
grinnnw <- fetchGrinnNetwork(txtInput=kw, from="metabolite", to="protein")
dummy <- rbind(nodetype=rep("metabolite"),t(mtcars))
colnames(dummy) <- c('G160','G300','G371','G367',paste0('G',sample(400:22000, 28)))
corrnw <- fetchCorrNetwork(datNormX=dummy, datNormY=NULL, corrCoef=0.5, pval= 1e-12, method="pearson", returnAs="tab")
corrnw
result <- combineNetwork(grinnnw,corrnw)
result
nld
neu
getGrinnDb()
queryNode()
querystring = "UNWIND ['coa','co2','Malonyl-CoA'] AS x WITH x MATCH (n:Metabolite) WHERE lower(n.name) = lower(x) RETURN DISTINCT n"
result = queryNode(querystring)
result
txtInput <- list('G371','G783')
result <- fetchNode(txtInput, nodetype="metabolite")
result
node - curlRequestCypher("UNWIND ['G371','G783'] AS x WITH x MATCH (node:Metabolite) WHERE node.GID = x RETURN DISTINCT node")
node = curlRequestCypher("UNWIND ['G371','G783'] AS x WITH x MATCH (node:Metabolite) WHERE node.GID = x RETURN DISTINCT node")
node
result
